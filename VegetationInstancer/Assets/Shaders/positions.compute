// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain


// terrain height related variables and functions -------------------------
StructuredBuffer<float> heightMap;
int resolution;
float4 sampleSize;
float4 AABBMin;
float4 AABBMax;
            
struct Triangle
{
    float3 V0;
    float3 V1;
    float3 V2;
    float3 Normal;
};

Triangle MakeTriangle(float3 v0, float3 v1, float3 v2)
{
    Triangle tri;
    tri.V0 = v0;
    tri.V1 = v1;
    tri.V2 = v2;
    tri.Normal = normalize(cross(v1 - v0, v2 - v0));
    return tri;
}

float TriSampleHeight(Triangle tri, float2 position)
{
// plane formula: a(x - x0) + b(y - y0) + c(z - z0) = 0
// <a,b,c> is a normal vector for the plane
// (x,y,z) and (x0,y0,z0) are any points on the plane
    return (-tri.Normal.x * (position.x - tri.V0.x) - tri.Normal.z * (position.y - tri.V0.z)) / tri.Normal.y + tri.V0.y;
}

bool IsWithinBounds(float2 worldPos)
{
    return
        worldPos.x >= AABBMin.x &&
        worldPos.y >= AABBMin.z &&
        worldPos.x <= AABBMax.x &&
        worldPos.y <= AABBMax.z;
}

float3 GetWorldVertex(int2 heightMapCrds)
{
    int i = heightMapCrds.x + heightMapCrds.y * resolution;
    float3 vertexPercentages = float3
    (
        (float) heightMapCrds.x / (resolution - 1),
        heightMap[heightMapCrds.x * resolution + heightMapCrds.y],
        (float) heightMapCrds.y / (resolution - 1)
    );
    return AABBMin.xyz + (AABBMax.xyz - AABBMin.xyz) * vertexPercentages;
}

Triangle GetTriAtPosition(float2 worldPosition)
{
    float2 localPos =
    float2(
            worldPosition.x - AABBMin.x,
            worldPosition.y - AABBMin.z);
    float2 samplePos = localPos / sampleSize.xy;
    int2 sampleFloor = int2(floor(samplePos.x), floor(samplePos.y));
    float2 sampleDecimal = samplePos - sampleFloor;
    bool upperLeftTri = sampleDecimal.y > sampleDecimal.x;
    int2 v1Offset = upperLeftTri ? int2(0, 1) : int2(1, 1);
    int2 v2Offset = upperLeftTri ? int2(1, 1) : int2(1, 0);
    float3 v0 = GetWorldVertex(sampleFloor);
    float3 v1 = GetWorldVertex(sampleFloor + v1Offset);
    float3 v2 = GetWorldVertex(sampleFloor + v2Offset);
    return MakeTriangle(v0, v1, v2);
}

float4 SampleHeight(float2 worldPosition)
{
    if (!IsWithinBounds(worldPosition)) // return crazy value instead of throwing an error
        return float4(-10000, 0, 0, 0);

    Triangle tri = GetTriAtPosition(worldPosition);
    return float4(TriSampleHeight(tri, worldPosition), tri.Normal.x, tri.Normal.y, tri.Normal.z);
}
// ------------------------------------------------------------------------
            
// texture related variables and functions --------------------------------
StructuredBuffer<float> textureMapAllTextures;
int terrainPosX;
int terrainPosY;
float terrainSizeX;
float terrainSizeY;
int textureArraySizeX;
int textureArraySizeY;
int resolutionTex;
int textureCount;

int round(float val)
{
    if (val % 1 > 0.5)
        return (int) (val + 1);
    return (int) (val);
}

float GetTextureAtPos(float2 worldPos, int texIndex)
{
    if (texIndex >= textureCount || texIndex < 0)
        return 0;

    // terrains cannot be rotated, so we don't have to worry about rotation
    float2 relativePosition = worldPos - float2(terrainPosX, terrainPosY);
    int2 pos = int2
    (
        (int) round((relativePosition.x / terrainSizeX) * textureArraySizeX),
        (int) round((relativePosition.y / terrainSizeY) * textureArraySizeY)
    );

    if (pos.x > textureArraySizeX)
        pos.x = textureArraySizeX - 1;
    if (pos.y > textureArraySizeY)
        pos.y = textureArraySizeY - 1;

    return textureMapAllTextures[pos.x + resolutionTex * (pos.y + textureCount * texIndex)];
}
// ---------------------------------------------------------------------

// generation related variables and function ------------------------------
StructuredBuffer<int4> chunksPositions;
float randomSeed;
float D1Size;
float chunkSize;
float plantDistance;
float maxSlope;
float sizeChange;
float displacement;
float falloff;
float sizeBias;
int textureIndex;

// generates random value between min and max
float GenerateRandom(float index, float min, float max)
{
    float seed = randomSeed * index * 0.193728912263;
    float fracVal = frac(sin(seed) * 43758.5453);
    float minMaxDist = max - min;
    return min + fracVal * minMaxDist;
}
            
float4x4 trs(float3 t, float4 r, float3 s)
{
    float4x4 res;
    res._11 = (1.0 - 2.0 * (r.y * r.y + r.z * r.z)) * s.x;
    res._21 = (r.x * r.y + r.z * r.w) * s.x * 2.0;
    res._31 = (r.x * r.z - r.y * r.w) * s.x * 2.0;
    res._41 = 0.0;
    res._12 = (r.x * r.y - r.z * r.w) * s.y * 2.0;
    res._22 = (1.0 - 2.0 * (r.x * r.x + r.z * r.z)) * s.y;
    res._32 = (r.y * r.z + r.x * r.w) * s.y * 2.0;
    res._42 = 0.0;
    res._13 = (r.x * r.z + r.y * r.w) * s.z * 2.0;
    res._23 = (r.y * r.z - r.x * r.w) * s.z * 2.0;
    res._33 = (1.0 - 2.0 * (r.x * r.x + r.y * r.y)) * s.z;
    res._43 = 0.0;
    res._14 = t.x;
    res._24 = t.y;
    res._34 = t.z;
    res._44 = 1.0;
    return res;
}

float4 EulerToQuaternion(float3 euler)
{
    float3 halfAngles = euler * 0.5;
    float3 c = cos(halfAngles);
    float3 s = sin(halfAngles);

    float4 qx = float4(s.x, 0, 0, c.x);
    float4 qy = float4(0, s.y, 0, c.y);
    float4 qz = float4(0, 0, s.z, c.z);

    float4 qxy = float4
    (
        qx.w * qy.x + qx.x * qy.w + qx.y * qy.z - qx.z * qy.y,
        qx.w * qy.y - qx.x * qy.z + qx.y * qy.w + qx.z * qy.x,
        qx.w * qy.z + qx.x * qy.y - qx.y * qy.x + qx.z * qy.w,
        qx.w * qy.w - qx.x * qy.x - qx.y * qy.y - qx.z * qy.z
    );

    return float4
    (
        qxy.w * qz.x + qxy.x * qz.w + qxy.y * qz.z - qxy.z * qz.y,
        qxy.w * qz.y - qxy.x * qz.z + qxy.y * qz.w + qxy.z * qz.x,
        qxy.w * qz.z + qxy.x * qz.y - qxy.y * qz.x + qxy.z * qz.w,
        qxy.w * qz.w - qxy.x * qz.x - qxy.y * qz.y - qxy.z * qz.z
    );
}

float4x4 GeneratePosRotScale(uint index, uint chunkIndex)
{
    float xDisplacement = GenerateRandom(index * 0.904735, -displacement, displacement);
    float zDisplacement = GenerateRandom(index * 0.290374, -displacement, displacement);
    
    float x = xDisplacement + chunksPositions[chunkIndex].x - chunkSize / 2 + (index / D1Size) * chunkSize / plantDistance;
    float z = zDisplacement + chunksPositions[chunkIndex].z - chunkSize / 2 + (index % D1Size) * chunkSize / plantDistance;
    float4 yAndNormal = SampleHeight(float2(x, z));
    float y = yAndNormal.x;
    float3 normal = yAndNormal.yzw;
    
    // get max allowed texture value
    float texValueAtPos = GetTextureAtPos(float2(x, z), textureIndex);

    // check slope and texture
    if (texValueAtPos < falloff || normal.y < maxSlope)
        return trs(float3(0, -10000, 0), float4(0, 0, 0, 1), float3(1, 1, 1));
    
    float3 pos = float3(x, y, z);
    float4 q = EulerToQuaternion(float3(0, GenerateRandom(index * 0.0983633, 0, 360), 0));
    float newSize = GenerateRandom(index * 0.45729204, 1 / sizeChange, sizeChange);
    if (texValueAtPos >= falloff)
        newSize *= max(texValueAtPos, 0.1);
    
    return trs(pos, q, newSize * sizeBias);
}
// ------------------------------------------------------------------------

float4x4 inverse(float4x4 input)
{
	//determinant(float3x3(input._22_23_23, input._32_33_34, input._42_43_44))
    #define minor(a,b,c) determinant(float3x3(input.a, input.b, input.c))
	
    float4x4 cofactors = float4x4(
		 minor(_22_23_24, _32_33_34, _42_43_44),
		-minor(_21_23_24, _31_33_34, _41_43_44),
		 minor(_21_22_24, _31_32_34, _41_42_44),
		-minor(_21_22_23, _31_32_33, _41_42_43),
		
		-minor(_12_13_14, _32_33_34, _42_43_44),
		 minor(_11_13_14, _31_33_34, _41_43_44),
		-minor(_11_12_14, _31_32_34, _41_42_44),
		 minor(_11_12_13, _31_32_33, _41_42_43),
		
		 minor(_12_13_14, _22_23_24, _42_43_44),
		-minor(_11_13_14, _21_23_24, _41_43_44),
		 minor(_11_12_14, _21_22_24, _41_42_44),
		-minor(_11_12_13, _21_22_23, _41_42_43),
		
		-minor(_12_13_14, _22_23_24, _32_33_34),
		 minor(_11_13_14, _21_23_24, _31_33_34),
		-minor(_11_12_14, _21_22_24, _31_32_34),
		 minor(_11_12_13, _21_22_23, _31_32_33)
	);
    #undef minor
    return transpose(cofactors) / determinant(input);
}

struct ItemInstanceData
{
    float4x4 mat;
    float4x4 matInverse;
    float4 infos;
};

ItemInstanceData MakeItemInstanceData(float4x4 mat)
{
    ItemInstanceData instanceItem;
    instanceItem.mat = mat;
    instanceItem.matInverse = inverse(mat);
    instanceItem.infos = float4(D1Size, 1, 1, 1);
    return instanceItem;
}

// output
RWStructuredBuffer<ItemInstanceData> positions;

[numthreads(64,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float4x4 mat = GeneratePosRotScale(id.x % (uint) (D1Size * D1Size), id.x / (uint) (D1Size * D1Size));
    ItemInstanceData instanceItem = MakeItemInstanceData(mat);
    positions[id.x] = instanceItem;
}
